<!DOCTYPE html>

<html>

  <head>
    <meta charset="UTF-8">
  </head>

  <body scroll="no">

    <canvas id="canvas" width=640 height=480></canvas>

    <script type="text/javascript" src="../libraries/arrayVec3D.js"></script>
    <script type="text/javascript" src="../libraries/matrix.js"></script>

      <!-- SHADERS -->

      <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec3 aVertexCoords;
        attribute vec4 aVertexColor;

        uniform mat4 uMVMatrix;
        uniform mat4 uProjMatrix;

        varying lowp vec4 vColor;

        void main(void){
          gl_Position = uProjMatrix * uMVMatrix * vec4(aVertexCoords, 1.0);
          vColor = aVertexColor;
        }
      </script>

      <script id="fragmentShader" type="x-shader/x-fragment">
        varying lowp vec4 vColor;

        void main(void){
          gl_FragColor = vColor;
        }
      </script>

      <!-- END SHADERS -->



      <script>
        var canvas = document.getElementById("canvas"),
          gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl"),
          bufVertexCoords = gl.createBuffer(),
          bufVertexColors = gl.createBuffer(),
          bufIndices = gl.createBuffer(),
          aVertexCoords = null,
          lastMouseX,
          lastMouseY,
          mvMatrix = $M4([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
            ]),
          projectionMatrix = (function(fovRads, aspect, near, far){
              var f = 1.0 / Math.tan(fovRads / 2);
              var rangeInverse = 1.0 / (near-far);
              return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near+far) * rangeInverse, -1,
                0, 0, near*far * rangeInverse * 2, 0
              ]);
            })(45 * Math.PI / 180, 640/480, 0.1, 100);



        // -- OPENGL BOILERPLATE --

          // -- COMPILE THE PROGRAM --

          // -- Fetch the shader scripts and make them into a shader program --
          function getShader(id, type){
            var script = document.getElementById(id).text;
            var shader = gl.createShader(type);
            gl.shaderSource(shader, script);
            gl.compileShader(shader);
            return shader;
          }
          var shader = gl.createProgram();
          gl.attachShader(shader, getShader("vertexShader", gl.VERTEX_SHADER));
          gl.attachShader(shader, getShader("fragmentShader", gl.FRAGMENT_SHADER));
          gl.linkProgram(shader);
          gl.useProgram(shader);
          gl.clearColor(0.0, 0.0, 0.0, 1.0);
          gl.clearDepth(1.0);
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.viewport(0,0, canvas.width, canvas.height);

          // -- SET UP THE ATTRIBUTES --

          // -- Fetch and save the location of the shader's vertices attribute for future use --
          aVertexCoords = gl.getAttribLocation(shader, "aVertexCoords");
          aVertexColor = gl.getAttribLocation(shader, "aVertexColor");

          uProjMatrix = gl.getUniformLocation(shader, "uProjMatrix");
          uMVMatrix = gl.getUniformLocation(shader, "uMVMatrix");

          // -- Enable the shader's vertices attribute --
          gl.enableVertexAttribArray(aVertexCoords);
          gl.enableVertexAttribArray(aVertexColor);

          // -- Convert array of vertex values into a GL array buffer --
          gl.bindBuffer(gl.ARRAY_BUFFER, bufVertexCoords);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
          ]), gl.STATIC_DRAW);
          // -- Point the array buffer at the shader's vertices attribute --
          // -- and tell it that it will be grabbing values 3 at a time --
          gl.bindBuffer(gl.ARRAY_BUFFER, bufVertexCoords);
          gl.vertexAttribPointer(aVertexCoords, 3, gl.FLOAT, false, 0, 0);

          gl.bindBuffer(gl.ARRAY_BUFFER, bufVertexColors);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            1.0,  1.0,  1.0,  1.0,    // Front face: white
            1.0,  1.0,  1.0,  1.0,
            1.0,  1.0,  1.0,  1.0,
            1.0,  1.0,  1.0,  1.0,

            1.0,  0.0,  0.0,  1.0,    // Back face: red
            1.0,  0.0,  0.0,  1.0,
            1.0,  0.0,  0.0,  1.0,
            1.0,  0.0,  0.0,  1.0,

            0.0,  1.0,  0.0,  1.0,    // Top face: green
            0.0,  1.0,  0.0,  1.0,
            0.0,  1.0,  0.0,  1.0,
            0.0,  1.0,  0.0,  1.0,

            0.0,  0.0,  1.0,  1.0,    // Bottom face: blue
            0.0,  0.0,  1.0,  1.0,
            0.0,  0.0,  1.0,  1.0,
            0.0,  0.0,  1.0,  1.0,

            1.0,  1.0,  0.0,  1.0,    // Right face: yellow
            1.0,  1.0,  0.0,  1.0,
            1.0,  1.0,  0.0,  1.0,
            1.0,  1.0,  0.0,  1.0,

            1.0,  0.0,  1.0,  1.0,     // Left face: purple)
            1.0,  0.0,  1.0,  1.0,
            1.0,  0.0,  1.0,  1.0,
            1.0,  0.0,  1.0,  1.0
          ]), gl.STATIC_DRAW);
          gl.vertexAttribPointer(aVertexColor, 4, gl.FLOAT, false, 0, 0);

          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufIndices);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([
            0,  1,  2,      0,  2,  3,    // front
            4,  5,  6,      4,  6,  7,    // back
            8,  9,  10,     8,  10, 11,   // top
            12, 13, 14,     12, 14, 15,   // bottom
            16, 17, 18,     16, 18, 19,   // right
            20, 21, 22,     20, 22, 23    // left
          ]), gl.STATIC_DRAW);

        // Init transformation values
        var rotationX = 0.0,
          rotationY = 0.0,
          rotationZ = 0.0,
          translateX = 0.0,
          translateY = 0.0,
          translateZ = -6.0;

        // -- END BOILERPLATE --

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mvMatrix = mvMatrix.timesMat4(Mat4.Rotation(1, 1, 1)).timesMat4(Mat4.Translation(0,0,-3));

        gl.uniformMatrix4fv(uProjMatrix, false, projectionMatrix);
        gl.uniformMatrix4fv(uMVMatrix, false, mvMatrix.toArray());


        function draw(){

          // Convert "mouse-space" rotation to modelspace rotation
          var rotMat = mvMatrix.timesMat4(Mat4.Rotation(-rotationX, rotationY, rotationZ));

          // Neutralize translation in the rotation matrix
          rotMat.elements[12] = 0.0;
          rotMat.elements[13] = 0.0;
          rotMat.elements[14] = 0.0;

          // Reset model matrix
          mvMatrix.makeIdentity();

          // Apply transformations to model matrix
          mvMatrix = mvMatrix.timesMat4(rotMat);
          mvMatrix = mvMatrix.timesMat4(Mat4.Translation(translateX, translateY, translateZ));
          gl.uniformMatrix4fv(uMVMatrix, false, mvMatrix.toArray());

          // Draw
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

          // Lower rotation value due to inertia
          rotationX /= 1.01;
          rotationY /= 1.01;
          rotationZ /= 1.01;

          function clampToZero(x){
            if (x < 0.001 && x > -0.001) {
              return 0;
            }
            return x;
          }

          rotationX = clampToZero(rotationX);
          rotationY = clampToZero(rotationY);
          rotationZ = clampToZero(rotationZ);

          // Loop
          requestAnimationFrame(draw);
        }

        canvas.onmousemove = function(e){
          if (e.buttons == 0){return;}
          if (lastMouseX){
            rotationY += -(e.clientX - lastMouseX) / 3000;
          }
          if (lastMouseY){
            rotationX += (e.clientY - lastMouseY) / 3000;
          }
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        }

        canvas.addEventListener("touchmove", function(e){
          if (lastMouseX){
            rotationY += -(e.touches[0].clientX - lastMouseX) / 3000;
          }
          if (lastMouseY){
            rotationX += (e.touches[0].clientY - lastMouseY) / 3000;
          }
          lastMouseX = e.touches[0].clientX;
          lastMouseY = e.touches[0].clientY;
        }, false);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufIndices);
        requestAnimationFrame(draw);
      </script>

  </body>

</html>