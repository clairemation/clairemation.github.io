<!DOCTYPE html>

<html>

  <head>
    <meta charset="UTF-8">
  </head>

  <body scroll="no" style="background: #000; text-align: center; vertical-align: center;">

    <h1 style="color: #fff;">Spin the cube!</h1>
    <canvas id="canvas" width=640 height=480 style="width: 70%;"></canvas>

    <script type="text/javascript" src="../libraries/arrayVec3D.js"></script>
    <script type="text/javascript" src="../libraries/matrix.js"></script>

      <!-- SHADERS -->

      <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec3 aVertexCoords;
        attribute vec4 aVertexColor;

        uniform mat4 uMVMatrix;
        uniform mat4 uProjMatrix;

        varying lowp vec4 vColor;

        void main(void){
          gl_Position = uProjMatrix * uMVMatrix * vec4(aVertexCoords, 1.0);
          vColor = aVertexColor;
        }
      </script>

      <script id="fragmentShader" type="x-shader/x-fragment">
        varying lowp vec4 vColor;

        void main(void){
          gl_FragColor = vColor;
        }
      </script>

      <!-- END SHADERS -->


      <script>
        // DECLARE GLOBALS
        var canvas = document.getElementById("canvas"),
          gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl"),
          lastMouseX,
          lastMouseY,
          mvMatrix = $M4([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
            ]),
          projectionMatrix = (function(fov, aspect, near, far){
              // Convert field of view to radians
              fov *= Math.PI / 180;
              var f = 1.0 / Math.tan(fov / 2);
              var rangeInverse = 1.0 / (near-far);
              return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near+far) * rangeInverse, -1,
                0, 0, near*far * rangeInverse * 2, 0
              ]);
            })(45, 640/480, 0.1, 100);
            // (field of view in degrees, canvas width/height, near clipping plane, far clipping plane)



        // -- OPENGL BOILERPLATE --

          // -- COMPILE THE PROGRAM --

          // -- Fetch the shader scripts and make them into a shader program --
          function getShader(id, type){
            var script = document.getElementById(id).text;
            var shader = gl.createShader(type);
            gl.shaderSource(shader, script);
            gl.compileShader(shader);
            return shader;
          }
          var shader = gl.createProgram();
          gl.attachShader(shader, getShader("vertexShader", gl.VERTEX_SHADER));
          gl.attachShader(shader, getShader("fragmentShader", gl.FRAGMENT_SHADER));
          gl.linkProgram(shader);
          gl.useProgram(shader);
          gl.clearColor(0.0, 0.0, 0.0, 1.0);
          gl.clearDepth(1.0);
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.viewport(0,0, canvas.width, canvas.height);

          // -- SET UP THE ATTRIBUTES --

          // -- Get references to the shader's attributes (vertices and face colors) --
          var aVertexCoords = gl.getAttribLocation(shader, "aVertexCoords");
          var aVertexColor = gl.getAttribLocation(shader, "aVertexColor");

          // -- Enable the attributes --
          gl.enableVertexAttribArray(aVertexCoords);
          gl.enableVertexAttribArray(aVertexColor);

          // -- Get references to the shader uniforms
          uProjMatrix = gl.getUniformLocation(shader, "uProjMatrix");
          uMVMatrix = gl.getUniformLocation(shader, "uMVMatrix");

          // -- Convert array of vertices into a GL array buffer and bind to the vertices attribute --
          // First create a GL buffer object
          var bufVertexCoords = gl.createBuffer();
          // Bind that buffer to GL's "current array buffer" reference to operate on
          gl.bindBuffer(gl.ARRAY_BUFFER, bufVertexCoords);
          // Enter data into the current array buffer
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
          ]), gl.STATIC_DRAW);
          // -- Point the current array buffer at the shader's vertices attribute, --
          // -- and tell it that it will be grabbing floating-point values 3 at a time --
          gl.vertexAttribPointer(aVertexCoords, 3, gl.FLOAT, false, 0, 0);

          // -- Same process for colors attribute --
          var bufVertexColors = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, bufVertexColors);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            1.0,  1.0,  1.0,  1.0,    // Front face: white
            1.0,  1.0,  1.0,  1.0,
            1.0,  1.0,  1.0,  1.0,
            1.0,  1.0,  1.0,  1.0,

            1.0,  0.0,  0.0,  1.0,    // Back face: red
            1.0,  0.0,  0.0,  1.0,
            1.0,  0.0,  0.0,  1.0,
            1.0,  0.0,  0.0,  1.0,

            0.0,  1.0,  0.0,  1.0,    // Top face: green
            0.0,  1.0,  0.0,  1.0,
            0.0,  1.0,  0.0,  1.0,
            0.0,  1.0,  0.0,  1.0,

            0.0,  0.0,  1.0,  1.0,    // Bottom face: blue
            0.0,  0.0,  1.0,  1.0,
            0.0,  0.0,  1.0,  1.0,
            0.0,  0.0,  1.0,  1.0,

            1.0,  1.0,  0.0,  1.0,    // Right face: yellow
            1.0,  1.0,  0.0,  1.0,
            1.0,  1.0,  0.0,  1.0,
            1.0,  1.0,  0.0,  1.0,

            1.0,  0.0,  1.0,  1.0,     // Left face: purple)
            1.0,  0.0,  1.0,  1.0,
            1.0,  0.0,  1.0,  1.0,
            1.0,  0.0,  1.0,  1.0
          ]), gl.STATIC_DRAW);
          gl.vertexAttribPointer(aVertexColor, 4, gl.FLOAT, false, 0, 0);

          // Now bind a new buffer to GL's current element array buffer.
          // This specifies which vertices make up each face.
          // It does not get bound to any shader attribute.
          // The drawElements call just automatically uses whatever is the current element array buffer.
          var bufIndices = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufIndices);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([
            0,  1,  2,      0,  2,  3,    // front
            4,  5,  6,      4,  6,  7,    // back
            8,  9,  10,     8,  10, 11,   // top
            12, 13, 14,     12, 14, 15,   // bottom
            16, 17, 18,     16, 18, 19,   // right
            20, 21, 22,     20, 22, 23    // left
          ]), gl.STATIC_DRAW);

        // Init transformation values
        var rotationX = 0.0,
          rotationY = 0.0,
          rotationZ = 0.0,
          translateX = 0.0,
          translateY = 0.0,
          translateZ = -6.0;

        // Set inital position for the model
        mvMatrix = mvMatrix.timesMat4(Mat4.Rotation(1, 1, 1)).timesMat4(Mat4.Translation(0,0,-3));

        // -- END BOILERPLATE --

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Pass the projection and modelview matrices into the shader uniforms
        gl.uniformMatrix4fv(uProjMatrix, false, projectionMatrix);
        gl.uniformMatrix4fv(uMVMatrix, false, mvMatrix.toArray());


        function draw(){

          // Convert "mouse-space" rotation to modelspace rotation
          var rotMat = mvMatrix.timesMat4(Mat4.Rotation(-rotationX, rotationY, rotationZ));

          // Neutralize translation that may have ended up in the rotation matrix
          rotMat.elements[12] = 0.0;
          rotMat.elements[13] = 0.0;
          rotMat.elements[14] = 0.0;

          // -- Rebuild model matrix from current transformations --
          mvMatrix = rotMat.timesMat4(Mat4.Translation(translateX, translateY, translateZ));
          // Pass model matrix to shader uniform
          gl.uniformMatrix4fv(uMVMatrix, false, mvMatrix.toArray());

          // -- Draw --
          // 36 vertices -> every 3 vertices become a triangle -> 12 triangles -> 6 squares/sides
          gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

          // Rotation drops off due to inertia
          rotationX /= 1.01;
          rotationY /= 1.01;
          rotationZ /= 1.01;
          function snapToZero(x){
            if (x < 0.001 && x > -0.001) {
              return 0;
            }
            return x;
          }
          rotationX = snapToZero(rotationX);
          rotationY = snapToZero(rotationY);
          rotationZ = snapToZero(rotationZ);

          // Loop
          requestAnimationFrame(draw);
        }

        // -- Add canvas event listeners for mouse drag or touch slide --

        canvas.onmousemove = function(e){
          if (e.buttons == 0){return;}
          if (lastMouseX){
            rotationY += -(e.clientX - lastMouseX) / 3000;
          }
          if (lastMouseY){
            rotationX += (e.clientY - lastMouseY) / 3000;
          }
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        }

        canvas.addEventListener("touchmove", function(e){
          e.preventDefault();
          if (lastMouseX){
            rotationY += -(e.touches[0].clientX - lastMouseX) / 3000;
          }
          if (lastMouseY){
            rotationX += (e.touches[0].clientY - lastMouseY) / 3000;
          }
          lastMouseX = e.touches[0].clientX;
          lastMouseY = e.touches[0].clientY;
        }, false);

        function resetMouse(e){
          lastMouseX = false;
          lastMouseY = false;
        }

        canvas.onmouseout = resetMouse;
        canvas.onmouseup = resetMouse;
        canvas.addEventListener("touchend", resetMouse);

        // -- Start the draw loop! --
        requestAnimationFrame(draw);
      </script>

  </body>

</html>