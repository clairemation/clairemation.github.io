<!DOCTYPE html>

<html>

  <head>
    <meta charset="UTF-8">

    <link href='hero.css' rel='stylesheet' type='text/css'>

  </head>

  <body scroll="no">

    <p>Control the scientist using the arrow keys. Avoid the fireballs and get the crystal!</p>
    <div with=1024 height=768 style="background: url('lavabg5.jpg'); background-repeat: no-repeat; padding: 0">
      <canvas id="display" width=1024 height=768></canvas>
    </div>

      <script>

      //* CONSTANTS ====================

      var walkmaskSrc = "data:image/gif;base64,R0lGODlhAAHAAIAAAP///wAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4zLWMwMTEgNjYuMTQ1NjYxLCAyMDEyLzAyLzA2LTE0OjU2OjI3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOkMxQTgwNTNGQUIyMDY4MTE4QzE0RUVCNUY2MjY3MDUzIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjEwMUFBRTdFMUVBNTExRTY5NjNFQjYyMTM5NkY4MzEwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjEwMUFBRTdEMUVBNTExRTY5NjNFQjYyMTM5NkY4MzEwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDowNTgwMTE3NDA3MjA2ODExODIyQUQ3OTg2QUVFMzE3MiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDMUE4MDUzRkFCMjA2ODExOEMxNEVFQjVGNjI2NzA1MyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAAAAAAALAAAAAAAAcAAAAL/jI+py+0Po5y02ouz3rz7D4biSJbmiabqyrbuC8fyTNf2jef6zvf+DwwKh8Si8YhMKpfMpvMJjUqn1Kr1is1qt9yu9wsOi8fksvmMTqvX7Lb7DY/L5/S6/Y7P6/f8vv8PGCg4SFhoeIiYqLjI2Oj4CBkpOVkFYAmwcGlJSabp+YnJ6QVK6inaVZp6eZql6rrJWvnqGis7q1o7dUubG7WL2wv1mxosPFxa/HRMmqy8/Nnc9AwdzTStWS19HZqttM3dnfQd7r3NSmx9fTq7ZE75G/NsMP4+zfGN/yqZ35Dvrw7p34F/BN01KogwobyDChs6fAjuDcSJFCuWqYgxI8Yt/xo7enTY6qPIkfyukDyJcpnJlCxbAqPiMqZMbLpm2oxZ86ZOlr52+kRp7KfQj0GHGs3o7KhSikmXOm1Y9KlUgT2nWqUn5arWhai2ejU15uvWi2Ktki0r9Szak3nWptRT0ArWO1TlGsSDjyPAtnOx2NvTN+QxPoEFw+N7l4tKvHm/cK1TctRiO40dT4ZcWMvjOZUtD6acWfNlzoklf6bT2fRp0qUVb44TWvRria1dz26TWvVqOLm73mbT2/ZoN5FX8DL+F3bwEuyQJ6ddm3lzFdHTLB9xOEX1M8VN7Pa+l/h1D8/Blwc+/l546efV+DsRm/z2Tt1FpNdwX8x78+tD5P8Psx9782XwHxj12XdgBwV6NuAGAfq3oG8N4vfgBwmacaGFFcoXX1gRWkAQgh3q9yGIG6pXomz9YXeigxnSNyGFL17QIoYjophiPzXCuKKIOTJQl3BQaRekgjvmBBF1ReJ4Y1MPKXmkiTvCog1TRC5JIFtEIHVllBO8FURHUHoZQUs+iDTmjBK4tMNILMTlwFI5kPSmW2qm6VGddjaJgpZ47vmbnm46B2iMLNIpaKE9/qmRC4r+6CKajj5qKIREvUBppSBICkOm7RHaqAyefpcol6KOmh2medaA6i6nhmpDq/q8uhEOsh5Ha5I63IrODBbxwCszNFgJbLDU+KrrmcZU0jQsSGEuGxGyCQ2haFTD/TCTH8gYUSs5sSbrra1DhtsmnOSei2666q7LbrvuvgtvvPLOS2+99t6Lb7767stvv/7+C3DAAg9McMEGH4xwwgovjEIBADs=";

      var images = {};
      var imagesToLoad = [
        ["heroStandingLeft", "hero_standing_left.png", 400, 400],
        ["heroStandingRight", "hero_standing_right.png", 400, 400],
        ["heroRunLeft", "hero_run_left.png", 1600, 400],
        ["heroRunRight", "hero_run_right.png", 1600, 400],
        ["walkmask", walkmaskSrc, 256, 192]
      ];

      for (var i = 0; i < imagesToLoad.length; i++){
        images[imagesToLoad[i][0]] = new Image(imagesToLoad[i][2], imagesToLoad[i][3]);
        images[imagesToLoad[i][0]].src = imagesToLoad[i][1];
      }

      loadCheckLoop = setInterval(function(){
        if (imagesToLoad.length <= 0){
          clearInterval(loadCheckLoop);
          main();
        }
        for (var i = 0; i < imagesToLoad.length; i++){
          if (images[imagesToLoad[i][0]].complete){
            imagesToLoad.splice(i,1);
          }
        }
      }, 10)

function main(){

      var UP_PRESS = 0,
          LEFT_PRESS = 1,
          DOWN_PRESS = 2,
          RIGHT_PRESS = 3,
          UP_RELEASE = 4,
          LEFT_RELEASE = 5,
          DOWN_RELEASE = 6,
          RIGHT_RELEASE = 7,
          RUN_RIGHT = 8,
          RUN_LEFT = 9,
          RUN_UP = 10,
          RUN_DOWN = 11,
          STOP_X = 12,
          STOP_Y = 13,
          HIT = 8;
      var FRAMERATE = 150; // milliseconds per frame
      var SCALE = .3;
      var WALKMASK_SCALE = 0.25 // 1/4th

      var walkmaskCvs = document.createElement("canvas");
      walkmaskCvs.width = 256;
      walkmaskCvs.height = 192;
      var walkmask = walkmaskCvs.getContext("2d");
      walkmask.drawImage(images.walkmask,0,0,256,192,0,0,256,192);

      //* COMPONENTS ====================

      //* IMPULSE COMPONENT ==========================

      function impulseComponent(obj){
        // Apply impulse to entity's acceleration, clamp to max speed
        obj.acceleration[0] += 1.25 * obj.impulse.x
        obj.acceleration[1] += 1.25 * obj.impulse.y;
        if (Math.abs(obj.acceleration[0]) > obj.maxSpeed){
          obj.acceleration[0] = obj.impulse.x * obj.maxSpeed;
        }
        if (Math.abs(obj.acceleration[1]) > obj.maxSpeed){
          obj.acceleration[1] = obj.impulse.y * obj.maxSpeed;
        }
      }

      //* GROUND CHECK COMPONENT =======================

      function groundIsWalkableComponent(obj){
        var accelerationDirection =
        ["N", "", "S"][Math.sign(obj.acceleration[1]) + 1]
        +
        ["W", "", "E"][Math.sign(obj.acceleration[0]) + 1];

        // check character's test pixel in given direction
        function groundSpotCheck(obj, direction){
          var sample = walkmask.getImageData(
                (Math.floor((obj.x + (obj.feetpoint[direction][0] * SCALE)) * WALKMASK_SCALE)),
                (Math.floor((obj.y + (obj.feetpoint[direction][1] * SCALE)) * WALKMASK_SCALE)),
                1,1
              );
          return (sample.data[0] == 255);
          // White means walkable. Black and white image so we only need to check one channel
        }
        var directionNeighbors = {
          "N": ["NW", "NE"],
          "NW": ["N", "W"],
          "W": ["NW", "SW"],
          "SW": ["W", "SE"],
          "S": ["SW", "SE"],
          "SE": ["S", "E"],
          "E": ["SE", "NE"],
          "NE": ["N", "E"]
        };

        if (accelerationDirection == ""){
          //if stopped, never mind
          return;
        }
        if (groundSpotCheck(obj, accelerationDirection)){
          // if walkable, go ahead
          return;
        }
        // Next test nearby diagonals
        var secondaryDirection = directionNeighbors[accelerationDirection][0];
        var tertiaryDirection = directionNeighbors[accelerationDirection][1];
        // Original speed = whichever acceleration factor wasn't 0
        if (obj.acceleration[0] == 0){
          var oldSpeed = Math.abs(obj.acceleration[1]);
        } else {
          var oldSpeed = Math.abs(obj.acceleration[0]);
        }
        // If new direction is ok, apply new direction while continuing to accelerate
        // TO DO: DRY this up
        if (groundSpotCheck(obj, secondaryDirection) == true){
          var newVector = obj.directionToImpulse(secondaryDirection);
          var newSpeedX = oldSpeed + 1.25;
          if (newSpeedX > obj.maxSpeed){
            newSpeedX = obj.maxSpeed;
          }
          var newSpeedY = oldSpeed + 1.25;
          if (newSpeedY > obj.maxSpeed){
            newSpeedY = obj.maxSpeed;
          }
          obj.acceleration = [newSpeedX * newVector[0], newSpeedY * newVector[1]];
          return;
        };
        if (groundSpotCheck(obj, tertiaryDirection) == true){
          var newVector = obj.directionToImpulse(tertiaryDirection);
          var newSpeedX = oldSpeed + 1.25;
          if (newSpeedX > obj.maxSpeed){
            newSpeedX = obj.maxSpeed;
          }
          var newSpeedY = oldSpeed + 1.25;
          if (newSpeedY > obj.maxSpeed){
            newSpeedY = obj.maxSpeed;
          }
          obj.acceleration = [newSpeedX * newVector[0], newSpeedY * newVector[1]];
          return;
        };
        // If all directions fail, bounce off
        obj.acceleration = [obj.acceleration[0] * -.75, obj.acceleration[1] * -.75];
        return;
      };

      //* MOVE COMPONENT ==========================

      function moveComponent(obj){
        if (obj.acceleration == [0,0]){
          return;
        }
        obj.x += Math.floor(obj.acceleration[0]);
        obj.y += Math.floor(obj.acceleration[1]);
        if (obj.onGround){
          obj.zIndex = obj.y + obj.height*SCALE;
        }
      }

      //* INERTIA COMPONENT ===============
      // TO DO: DRY this up

      function inertiaComponent(obj){
        // Always nudge acceleration back towards 0, clamp to 0
        if (obj.acceleration[0] > 0){
          obj.acceleration[0] -= 1;
          if (obj.acceleration[0] < 0){
            obj.acceleration[0] = 0;
          }
        }
        if (obj.acceleration[0] < 0){
          obj.acceleration[0] += 1;
          if (obj.acceleration[0] > 0){
            obj.acceleration[0] = 0;
          }
        }
        if (obj.acceleration[1] > 0){
          obj.acceleration[1] -= 1;
          if (obj.acceleration[1] < 0){
            obj.acceleration[1] = 0;
          }
        }
        if (obj.acceleration[1] < 0){
          obj.acceleration[1] += 1;
          if (obj.acceleration[1] > 0){
            obj.acceleration[1] = 0;
          }
        }
      }

      //* COLLISION COMPONENT =============
      // Could optimize with quad trees etc. but right now there are so few entities onscreen it's not really a big deal.
      // TO DO: make this run outside of the entities. Register entities & what they have to check collision with.
      // E.g. Fireball-class objects only have to check for collision with the Hero, the Hero checks for collision with basically everything, nonmoving objects aren't even registered.
      // This should save a lot of checks.

      function detectCollisionComponent(obj){
        if (obj.acceleration == [0,0]
          || entities.length == 1){
          return;
        }

        for (var i = 0; i < entities.length; i++){
          if (entities[i] != obj) {

            // TO DO: make this more precise
            // if (obj.facing == "W" && obj.x < entities[i].x){
            //   break;
            // }
            // if (obj.facing == "E" && obj.x > entities[i].x){
            //   break;
            // }

            // collision if:
            if (

            // -our feet are roughly at the same depth, and NOT...
              (Math.abs((entities[i].zIndex) - (obj.zIndex)) < Math.max(obj.depth, entities[i].depth) * SCALE)
              &&
            // -my left side is greater than its right side
            // AKA it clears me on my left side
              ((obj.x + obj.hitbox[0] - 1) <= (entities[i].x + entities[i].hitbox[2]))
              &&
            // -my right is less than its left
            // AKA clears me on my right
              ((obj.x + obj.hitbox[2] + 1) >= (entities[i].x + entities[i].hitbox[0]))
              &&
            // -my top is below its bottom
              ((obj.y + obj.hitbox[1]) - 1 <= (entities[i].y + entities[i].hitbox[3]))
              &&
            // -my bottom is above its top
            ((obj.y + obj.hitbox[3] + 1) >= (entities[i].y + entities[i].hitbox[1]))
            ){
              // collision!
              // message the obstacle
              obj.message(entities[i], direction);
              // get direction of obstacle in [x,y] form
              // bounce obj back if both are solid
              var direction = obj.directionToImpulse(obj.directionTo( entities[i]));
              if (obj.solid && entities[i].solid){
                obj.bounceBack(direction);
              }
            }
          }
        }
      };


      //* CLASSES ====================================

      //* BASE ENTITY CLASS ====================

      function GameEntity(){
        this.onGround = true;
        this.commandEnabled = false;
      };

      GameEntity.prototype.changeState = function(targetState){
        if (this.state != targetState){
          this.state = targetState;
          this.currentAnimationFrameNumber = 0;
        }
      }

      GameEntity.prototype.message = function(recipient, message){
        recipient.receiver(this.hitMessage, this);
      };

      GameEntity.prototype.receiver = function(message){};

      GameEntity.prototype.execute = function(script){

      }

      GameEntity.prototype.update = function(){};

      GameEntity.prototype.advanceFrame = function(timestamp){
        if (!this.lastTime){
          this.lastTime = timestamp;
        }
        var delta = timestamp - this.lastTime;
        var frameAdvance = Math.floor(delta / FRAMERATE);
        if (frameAdvance >= 1){
          this.currentAnimationFrameNumber = this.currentAnimationFrameNumber + frameAdvance;
          this.lastTime = timestamp;
          if (this.currentAnimationFrameNumber >= this.animation[this.state][this.facing].frames.length) {
            this.currentAnimationFrameNumber = this.animation[this.state][this.facing].frames[0];
          }
        }
        var c = this.currentAnimationFrame.getContext("2d");
        c.clearRect(0,0,this.width, this.height);
        c.drawImage(
          this.currentSpriteSheet, //source image
          (this.currentAnimationFrameNumber * this.width), //origin x
          0, //origin y
          this.width,
          this.height,
          0,0,
          this.width, this.height
        );
        // this.frameEffects(c);
      }

      // GameEntity.prototype.frameEffects = function(context){};

      GameEntity.prototype.setFrameEffects = function(effectFunction, duration){

      }

      GameEntity.prototype.updateFacing = function(){
        if (this.impulse.x == 0 && this.impulse.y == 0){
          return;
        }
        this.facing =
          ["N", "", "S"][this.impulse.y + 1]
          +
          ["W", "", "E"][this.impulse.x + 1];
      }

      GameEntity.prototype.directionTo = function(other){
        if (this.zIndex > other.zIndex){
          var y = -1;
        } else if (this.zIndex == other.zIndex) {
          var y = 0;
        } else {
          var y = 1;
        }
        if ((this.x + this.width/2) > (other.x + other.width/2)){
          var x = -1;
        } else if ((this.x + this.width/2) == (other.x + other.width/2)) {
          var x = 0;
        } else {
          var x = 1;
        }
        return (
        ["N", "", "S"][y + 1]
        +
        ["W", "", "E"][x + 1]
        );
      }

      GameEntity.prototype.directionToImpulse = function(direction){
        return {
          "N": [0,-1],
          "NW": [-1,-1],
          "W": [-1,0],
          "SW": [-1,1],
          "S": [0,1],
          "SE": [1,1],
          "E": [1,0],
          "NE": [1,-1]
        }[direction];
      }

      GameEntity.prototype.bounceBack = function(direction){
        if (Math.sign(this.acceleration[0]) == direction[0]){
          this.acceleration[0] *= -.85;
        }
        if (Math.sign(this.acceleration[1]) == direction[1]){
          this.acceleration[1] *= -.85;
        }
      }

      //* GAME OBJECTS ====================

      //* ACTOR ======================

      function Actor(){ // < GameEntity
        GameEntity.call(this);

        //* STATE ==================
        this.name = "hero";
        this.behavior = new NormalState(this);
        this.state = "standing";
        this.solid = true;
        this.canCollideWith = [Actor, Fireball, Crystal];
        this.width = 400;
        this.height = 400;
        this.depth = 50;
        this.x = 0;
        this.y = 0;
        this.impulse = {x: 0, y:0};
        this.facing = "E";
        this.maxSpeed = 7;
        this.acceleration = [0,0];
        this.hitbox = [125*SCALE,30*SCALE,265*SCALE,380*SCALE];
        this.feetpoint = { // test pixels for ground checks
          "N": [200, 345],
          "NW": [120, 345],
          "W": [120, 390],
          "SW": [120, 410],
          "S": [200, 410],
          "SE": [280, 410],
          "E": [280,390],
          "NE": [280,345]
        };
        this.animation = {
          "standing": {
            "N": {
              frames: [0],
              spritesheet: images.heroStandingLeft
            },
            "NW": {
              frames: [0],
              spritesheet: images.heroStandingLeft
            },
            "W": {
              frames: [0],
              spritesheet: images.heroStandingLeft
            },
            "SW": {
              frames: [0],
              spritesheet: images.heroStandingLeft
            },
            "S": {
              frames: [0],
              spritesheet: images.heroStandingRight
            },
            "SE": {
              frames: [0],
              spritesheet: images.heroStandingRight
            },
            "E": {
              frames: [0],
              spritesheet: images.heroStandingRight
            },
            "NE": {
              frames: [0],
              spritesheet: images.heroStandingRight
            },
          },
          "running": {
            "N": {
              frames: [0,1,2,3],
              spritesheet: images.heroRunLeft
            },
            "NW": {
              frames: [0,1,2,3],
              spritesheet: images.heroRunLeft
            },
            "W": {
              frames: [0,1,2,3],
              spritesheet: images.heroRunLeft
            },
            "SW": {
              frames: [0,1,2,3],
              spritesheet: images.heroRunLeft
            },
            "S": {
              frames: [0,1,2,3],
              spritesheet: images.heroRunRight
            },
            "SE": {
              frames: [0,1,2,3],
              spritesheet: images.heroRunRight
            },
            "E": {
              frames: [0,1,2,3],
              spritesheet: images.heroRunRight
            },
            "NE": {
              frames: [0,1,2,3],
              spritesheet: images.heroRunRight
            },
          }
        };
        this.currentSpriteSheet = this.animation[this.state][this.facing].spritesheet;
        this.currentAnimationFrameNumber = 0;
        this.currentAnimationFrame = document.createElement("canvas");
        this.currentAnimationFrame.width = this.width;
        this.currentAnimationFrame.height = this.height;
        this.lastTime = undefined;
      };

      //* METHODS =================

      //* INHERIT METHODS FROM BASE GAME ENTITY ===========
      Actor.prototype = Object.create(GameEntity.prototype);
      Actor.prototype.constructor = Actor;
      //* OWN METHODS ===============
      Actor.prototype.command = function(input){
        switch (input){
          case (RUN_UP):
            this.impulse.y = -1;
            this.changeState("running");
          break;
          case (RUN_LEFT):
            this.impulse.x = -1;
            this.changeState("running");
          break;
          case(RUN_DOWN):
            this.impulse.y = 1;
            this.changeState("running");
          break;
          case(RUN_RIGHT):
            this.impulse.x = 1;
            this.changeState("running");
          break;
          case (STOP_X):
            this.impulse.x = 0;
            if (this.impulse.y == 0){
              this.changeState("standing");
            }
          break;
          case (STOP_Y):
            this.impulse.y = 0;
            if (this.impulse.x == 0){
              this.changeState("standing");
            }
          break;
        }
        this.updateFacing();
      }

      Actor.prototype.receiver = function(message, sender){
        if (message == "burn"){
          // recoil
          var direction = this.directionToImpulse(this.directionTo(sender));
          this.acceleration[0] = direction[0] * -6;
          this.acceleration[1] = direction[1] * -6;
          // sprite effect
          this.behavior = new HurtState(this);
        }
      }

      Actor.prototype.update = function(timestamp){
        this.behavior.update(timestamp);
      }


      //* BEHAVIOR STATES ======================
      // TO DO: each entity's current state should be held in a state stack. Normal is the base. Other states such as Hurt or climbing etc. are pushed to the stack and popped when finished so you return to whatever you were in before.

      function NormalState(obj){
        this.obj = obj;
      }

      NormalState.prototype.update = function(timestamp){
        // Hot-swappable -- but careful of the order!
        // Check for walls and obstacles AFTER all updates are made to impulse and inertia
        impulseComponent(this.obj); // apply impulse to acceleration
        inertiaComponent(this.obj); // acceleration falls off gradually
        groundIsWalkableComponent(this.obj); // walls stop you or nudge you along at a diagonal
        detectCollisionComponent(this.obj); // you stop at obstacles and send them a message
        moveComponent(this.obj); // apply movement calculations to position
        this.obj.currentSpriteSheet = this.obj.animation[this.obj.state][this.obj.facing].spritesheet;
        this.obj.advanceFrame(timestamp); // advance animation frame
      };


      function HurtState(obj){
        this.obj = obj;
        this.countdown = 5;
      };

      HurtState.prototype.update = function(timestamp){
        // impulseComponent(this.obj);
        inertiaComponent(this.obj);
        groundIsWalkableComponent(this.obj);
        detectCollisionComponent(this.obj);
        moveComponent(this.obj);
        this.obj.currentSpriteSheet = this.obj.animation[this.obj.state][this.obj.facing].spritesheet;
        this.obj.advanceFrame(timestamp);

        // hurt frame effect
        var ctx = this.obj.currentAnimationFrame.getContext("2d");
        ctx.globalCompositeOperation = "source-in";
        ctx.fillStyle = "red";
        ctx.fillRect(0,0,this.obj.width,this.obj.height);
        ctx.globalCompositeOperation = "source-over";

        // effect countdown
        this.countdown --;
        if (this.countdown <= 0){
          this.obj.behavior = new NormalState(this.obj);
        }
      }


      //* PLAYER CLASS =====================
      // TO DO: move all command stuff from Actor into Player

      function Player(){ // < Actor
        Actor.call(this);
      }
      Player.prototype = Object.create(Actor.prototype);
      Player.prototype.constructor = Player;

      //* FIREBALLS ========================

      function Fireball(){ // < GameEntity
        GameEntity.call(this);
        this.name = "fireball";
        this.facing = null;
        this.solid = false;
        this.canCollideWith = [Player];
        this.onGround = false;
        this.width = 200;
        this.height = 200;
        this.depth = 100;
        this.x = -200;
        this.y = -200;
        this.originalX = 1100;
        this.originalY = -100;
        this.zIndex = 500;
        this.acceleration = [-7, 1];
        this.originalAcceleration = [-7, 1];
        this.hitbox = [50,50,150,150];
        this.hitMessage = "burn";
        this.currentAnimationFrame = document.createElement("canvas");
        this.currentAnimationFrame.width = this.width;
        this.currentAnimationFrame.height = this.height;

        var ctx = this.currentAnimationFrame.getContext("2d");
        ctx.beginPath();
        ctx.arc(100,100,100,0,2*Math.PI, false);
        ctx.fillStyle = "hsla(1,99%,60%,.5)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(100,100,75,0,2*Math.PI, false);
        ctx.fillStyle = "hsla(1,99%,60%,.5)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(100,100,50,0,2*Math.PI, false);
        ctx.fillStyle = "orange";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(100,100,25,0,2*Math.PI, false);
        ctx.fillStyle = "yellow";
      }

      Fireball.prototype = Object.create(GameEntity.prototype);
      Fireball.prototype.constructor = Fireball;

      Fireball.prototype.update = function(){
        detectCollisionComponent(this);
        moveComponent(this);
        if (this.y >= (this.zIndex - (this.height)*SCALE)){
          //restart
          this.x = this.originalX;
          this.y = this.originalY;
          this.acceleration = [this.originalAcceleration[0], this.originalAcceleration[1]];
        }
        this.acceleration[1] *= 1.06;
      }

      //* CRYSTAL CLASS ===============================
      function Crystal(){ // < GameEntity
        GameEntity.call(this);
        this.x = 550;
        this.y = 200;
        this.width = 100;
        this.height = 100;
        this.zIndex = this.y + (this.height * SCALE);
        this.depth = 10;
        this.hitbox = [0,0,this.width,this.height];
        this.solid = true;
        this.currentAnimationFrame = document.createElement("canvas");
        this.currentAnimationFrame.width = this.width;
        this.currentAnimationFrame.height = this.height;

        var ctx = this.currentAnimationFrame.getContext("2d");
        ctx.fillStyle = "aqua";
        ctx.fillRect(0,0,this.width,this.height);
      }

      Crystal.prototype = Object.create(GameEntity.prototype);
      Crystal.prototype.constructor = Crystal;

      Crystal.prototype.receiver = function(message,sender){
        alert("You win!");
      }


      //* GLOBAL ===========================

      function drawEntity(entity, context){
        context.drawImage(
          entity.currentAnimationFrame, //image
          0, 0, //origin x, y
          entity.width, entity.height, //origin w & h
          entity.x, entity.y, //map position
          (entity.width * SCALE), //drawn width and height
          (entity.height * SCALE)
        );
      };

      //* ===============================

      var hero = new Player(),
          twin = new Actor(),
          fireball = new Fireball(),
          fireball2 = new Fireball(),
          crystal = new Crystal();
          canvas = document.getElementById("display"),
          ctx = canvas.getContext('2d');

      var entities = [hero,twin,fireball,fireball2,crystal];
      var entitiesByDepthOrder = [hero,fireball,twin,fireball2,crystal];

      hero.x = 160;
      hero.y = 210;

      twin.name = "twin";
      twin.x = 600;
      twin.y = 200;
      twin.command = function(){};

      fireball2.x = -100;
      fireball2.y = -75;
      fireball2.originalX = 1100;
      fireball2.originalY = -75
      fireball2.acceleration = [-15,1];
      fireball2.originalAcceleration = [-15,1];
      fireball2.zIndex = 500;

      //* BEGIN GAME LOOP ====================
      var gameLoop = window.requestAnimationFrame(tick);

      function tick(timestamp){
        window.requestAnimationFrame(tick);
        for (var i = 0; i < entities.length; i++){
          entities[i].update(timestamp);
        };
        entitiesByDepthOrder.sort(function(a, b){
          return ((a.zIndex) - (b.zIndex));
        });
        ctx.clearRect(0, 0, 1200, 800);
        for (var i = 0; i < entitiesByDepthOrder.length; i++){
          drawEntity(entitiesByDepthOrder[i], ctx);
        }
      };

      //* KEY LISTENERS ========================

      window.addEventListener("keydown", function(e){
        switch (e.keyCode){
          case 37:
              e.preventDefault();
              keyHandler.register(LEFT_PRESS);
              break;
          case 38:
              e.preventDefault();
              keyHandler.register(UP_PRESS);
              break;
          case 39:
              e.preventDefault();
              keyHandler.register(RIGHT_PRESS);
              break;
          case 40:
              e.preventDefault();
              keyHandler.register(DOWN_PRESS);
              break;
        }
      });

      window.addEventListener("keyup", function(e){
        switch (e.keyCode){
          case 37:
            keyHandler.register(LEFT_RELEASE);
            break;
          case 38:
            keyHandler.register(UP_RELEASE);
            break;
          case 39:
            keyHandler.register(RIGHT_RELEASE);
            break;
          case 40:
            keyHandler.register(DOWN_RELEASE);
            break;
        }
      });


      //* GAME CONTROLLER ====================
      function GameController(){

      }
      GameController.prototype.command = function(obj, input){
        obj.command(input);
      }


      //* BUTTON COMPONENTS ===================

      // TO DO: put inside keyhandler class

      // FSM for X and Y button states, to manage multiple-key inputs

      var xNeutral = function(input){
        switch (input){
          case (LEFT_PRESS):
            hero.command(RUN_LEFT);
            keyHandler.xArrowKeyHandler = leftArrowPressed;
          break;
          case (RIGHT_PRESS):
            hero.command(RUN_RIGHT);
            keyHandler.xArrowKeyHandler = rightArrowPressed;
          break;
        }
      };

      var leftArrowPressed = function(input){
        switch (input){
          case (LEFT_RELEASE):
            hero.command(STOP_X)
            keyHandler.xArrowKeyHandler = xNeutral;
          break;
          case (RIGHT_PRESS):
            hero.command(RUN_RIGHT)
            keyHandler.xArrowKeyHandler = leftAndRightArrowsPressed;
          break;
        }
      };

      var rightArrowPressed = function(input){
        switch (input){
          case (RIGHT_RELEASE):
            hero.command(STOP_X);
            keyHandler.xArrowKeyHandler = xNeutral;
          break;
          case (LEFT_PRESS):
            hero.command(RUN_LEFT);
            keyHandler.xArrowKeyHandler = leftAndRightArrowsPressed
            break;
        }
      };

      var leftAndRightArrowsPressed = function(input){
        switch (input){
          case (LEFT_RELEASE):
            hero.command(RUN_RIGHT);
            keyHandler.xArrowKeyHandler = rightArrowPressed;
          break;
          case (RIGHT_RELEASE):
            hero.command(RUN_LEFT);
            keyHandler.xArrowKeyHandler = leftArrowPressed;
          break;
        }
      };

      var yNeutral = function(input){
        switch (input){
          case (UP_PRESS):
            hero.command(RUN_UP);
            keyHandler.yArrowKeyHandler = upArrowPressed;
          break;
          case (DOWN_PRESS):
            hero.command(RUN_DOWN);
            keyHandler.yArrowKeyHandler = downArrowPressed;
          break;
        }
      };

      var upArrowPressed = function(input){
        switch (input){
          case (UP_RELEASE):
            hero.command(STOP_Y);
            keyHandler.yArrowKeyHandler = yNeutral;
          break;
          case (DOWN_PRESS):
            hero.command(RUN_DOWN);
            keyHandler.yArrowKeyHandler = upAndDownArrowsPressed;
          break;
        }
      };

      var downArrowPressed = function(input){
        switch (input){
          case (DOWN_RELEASE):
            hero.command(STOP_Y);
            keyHandler.yArrowKeyHandler = yNeutral;
          break;
          case (UP_PRESS):
            hero.command(RUN_UP);
            keyHandler.yArrowKeyHandler = upAndDownArrowsPressed;
            break;
        }
      };

      var upAndDownArrowsPressed = function(input){
        switch (input){
          case (UP_RELEASE):
            hero.command(RUN_DOWN);
            keyHandler.yArrowKeyHandler = downArrowPressed;
          break;
          case (DOWN_RELEASE):
            hero.command(RUN_UP);
            keyHandler.yArrowKeyHandler = upArrowPressed;
          break;
        }
      };

      function KeyHandlerClass(){
        this.xArrowKeyHandler = xNeutral,
        this.yArrowKeyHandler = yNeutral
      }
      KeyHandlerClass.prototype.register = function(input){
        this.xArrowKeyHandler(input);
        this.yArrowKeyHandler(input);
      }

      var keyHandler = new KeyHandlerClass();

};

// main();
      </script>



  </body>

</html>