<!DOCTYPE html>

<html>

  <head>
    <meta charset="UTF-8">

    <link href='hero.css' rel='stylesheet' type='text/css'>

  </head>

  <body scroll="no">

    <div with=1024 height=768 style="background: url('lavabg4.jpg'); background-repeat: no-repeat; padding: 0">
      <canvas id="display" width=1024 height=768></canvas>
    </div>

      <script>

      //* CONSTANTS ====================

      var walkmaskimg = new Image(64,48);

      walkmaskimg.addEventListener("load", main);

      walkmaskimg.src = "data:image/gif;base64,R0lGODlhAAHAAIAAAP///wAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4zLWMwMTEgNjYuMTQ1NjYxLCAyMDEyLzAyLzA2LTE0OjU2OjI3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOkMxQTgwNTNGQUIyMDY4MTE4QzE0RUVCNUY2MjY3MDUzIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjEwMUFBRTdFMUVBNTExRTY5NjNFQjYyMTM5NkY4MzEwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjEwMUFBRTdEMUVBNTExRTY5NjNFQjYyMTM5NkY4MzEwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDowNTgwMTE3NDA3MjA2ODExODIyQUQ3OTg2QUVFMzE3MiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDMUE4MDUzRkFCMjA2ODExOEMxNEVFQjVGNjI2NzA1MyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAAAAAAALAAAAAAAAcAAAAL/jI+py+0Po5y02ouz3rz7D4biSJbmiabqyrbuC8fyTNf2jef6zvf+DwwKh8Si8YhMKpfMpvMJjUqn1Kr1is1qt9yu9wsOi8fksvmMTqvX7Lb7DY/L5/S6/Y7P6/f8vv8PGCg4SFhoeIiYqLjI2Oj4CBkpOVkFYAmwcGlJSabp+YnJ6QVK6inaVZp6eZql6rrJWvnqGis7q1o7dUubG7WL2wv1mxosPFxa/HRMmqy8/Nnc9AwdzTStWS19HZqttM3dnfQd7r3NSmx9fTq7ZE75G/NsMP4+zfGN/yqZ35Dvrw7p34F/BN01KogwobyDChs6fAjuDcSJFCuWqYgxI8Yt/xo7enTY6qPIkfyukDyJcpnJlCxbAqPiMqZMbLpm2oxZ86ZOlr52+kRp7KfQj0GHGs3o7KhSikmXOm1Y9KlUgT2nWqUn5arWhai2ejU15uvWi2Ktki0r9Szak3nWptRT0ArWO1TlGsSDjyPAtnOx2NvTN+QxPoEFw+N7l4tKvHm/cK1TctRiO40dT4ZcWMvjOZUtD6acWfNlzoklf6bT2fRp0qUVb44TWvRria1dz26TWvVqOLm73mbT2/ZoN5FX8DL+F3bwEuyQJ6ddm3lzFdHTLB9xOEX1M8VN7Pa+l/h1D8/Blwc+/l546efV+DsRm/z2Tt1FpNdwX8x78+tD5P8Psx9782XwHxj12XdgBwV6NuAGAfq3oG8N4vfgBwmacaGFFcoXX1gRWkAQgh3q9yGIG6pXomz9YXeigxnSNyGFL17QIoYjophiPzXCuKKIOTJQl3BQaRekgjvmBBF1ReJ4Y1MPKXmkiTvCog1TRC5JIFtEIHVllBO8FURHUHoZQUs+iDTmjBK4tMNILMTlwFI5kPSmW2qm6VGddjaJgpZ47vmbnm46B2iMLNIpaKE9/qmRC4r+6CKajj5qKIREvUBppSBICkOm7RHaqAyefpcol6KOmh2medaA6i6nhmpDq/q8uhEOsh5Ha5I63IrODBbxwCszNFgJbLDU+KrrmcZU0jQsSGEuGxGyCQ2haFTD/TCTH8gYUSs5sSbrra1DhtsmnOSei2666q7LbrvuvgtvvPLOS2+99t6Lb7767stvv/7+C3DAAg9McMEGH4xwwgovjEIBADs=";

function main(){

      var RUN_RIGHT = 0;
      var RUN_LEFT = 1;
      var RUN_UP = 2;
      var RUN_DOWN = 3;
      var STOP_LEFT = 4;
      var STOP_RIGHT = 5;
      var STOP_UP = 6;
      var STOP_DOWN = 7;
      var HIT = 8;
      var FRAMERATE = 150; // milliseconds per frame
      var SCALE = .3;
      var WALKMASK_SCALE = 0.25 // 1/4th

      var walkmaskCvs = document.createElement("canvas");
      walkmaskCvs.width = 256;
      walkmaskCvs.height = 192;
      var walkmask = walkmaskCvs.getContext("2d");
      walkmask.drawImage(walkmaskimg,0,0,256,192,0,0,256,192);

      //* COMPONENTS ====================

      //* MOVEMENT COMPONENT ================

      function movementComponent(obj){
        if (obj.acceleration == [0,0]){
          return;
        }
        obj.x += Math.floor(obj.acceleration[0]);
        obj.y += Math.floor(obj.acceleration[1]);
        if (obj.onGround){
          obj.zIndex = obj.y + obj.height*SCALE;
        }
      }

      //* COLLISION COMPONENT =============

      function detectCollisionComponent(obj){
        if (obj.acceleration == [0,0]){
          return;
        }
        if (entities.length == 1){
          return;
        }
        for (var i = 0; i < entities.length; i++){
          if (entities[i] != obj) {

            if (obj.facing == "W" && obj.x < entities[i].x){
              break;
            }
            if (obj.facing == "E" && obj.x > entities[i].x){
              break;
            }

            // if our feet are not roughly at the same depth, no collision
            if (Math.abs((entities[i].zIndex) - (obj.zIndex)) >= Math.max(obj.depth, entities[i].depth) * SCALE){
              break;
            }

            // if my left side is greater than its right side
            if ((obj.x + obj.hitbox[0]) - 1> (entities[i].x + entities[i].hitbox[2])){
                break;
            }
            // if my right is less than its left
            if ((obj.x + obj.hitbox[2] + 1) < (entities[i].x + entities[i].hitbox[0])){
                break;
            }
            // if my top is below its bottom
            if ((obj.y + obj.hitbox[1]) - 1 > (entities[i].y + entities[i].hitbox[3])){
                break;
            }
            // if my bottom is above its top
            if ((obj.y + obj.hitbox[3] + 1) < (entities[i].y + entities[i].hitbox[1])){
                break;
            }
            obj.message(entities[i], HIT);
            if (obj.solid){
              obj.acceleration = [0,0];
            }
          }
        }
      };

      // GROUND COMPONENT =================

      function groundIsWalkableComponent(obj){
        // check character's test pixel for given direction
        function groundSpotCheck(obj, direction){
          var sample = walkmask.getImageData(
                (Math.floor((obj.x + (obj.feetpoint[direction][0] * SCALE)) * WALKMASK_SCALE)),
                (Math.floor((obj.y + (obj.feetpoint[direction][1] * SCALE)) * WALKMASK_SCALE)),
                1,1
              );
          return (sample.data[0] == 255);
          // White means walkable. Black and white image so we only need to check one channel
        }
        var directionNeighbors = {
          "N": ["NW", "NE"],
          "NW": ["N", "W"],
          "W": ["NW", "SW"],
          "SW": ["W", "SE"],
          "S": ["SW", "SE"],
          "SE": ["S", "E"],
          "E": ["SE", "NE"],
          "NE": ["N", "E"]
        };
        var directionToMovement = {
          "N": [0,-1],
          "NW": [-1,-1],
          "W": [-1,0],
          "SW": [-1,1],
          "S": [0,1],
          "SE": [1,1],
          "E": [1,0],
          "NE": [1,-1]
        }
        if (obj.acceleration == [0,0]){
          //if stopped, never mind
          return;
        }
        if (groundSpotCheck(obj, obj.facing) == true){
          // if walkable, go ahead
          return;
        }
        // Next test diagonals
        var secondaryDirection = directionNeighbors[obj.facing][0];
        var tertiaryDirection = directionNeighbors[obj.facing][1];
        // Original speed = whichever acceleration factor wasn't 0
        if (obj.acceleration[0] == 0){
          var oldSpeed = Math.abs(obj.acceleration[1]);
        } else {
          var oldSpeed = Math.abs(obj.acceleration[0]);
        }
        // If new direction is ok, apply new direction while continuing to accelerate
        if (groundSpotCheck(obj, secondaryDirection) == true){
          var newVector = directionToMovement[secondaryDirection];
          var newSpeedX = oldSpeed + 1.25;
          if (newSpeedX > obj.maxSpeed){
            newSpeedX = obj.maxSpeed;
          }
          var newSpeedY = oldSpeed + 1.25;
          if (newSpeedY > obj.maxSpeed){
            newSpeedY = obj.maxSpeed;
          }
          obj.acceleration = [newSpeedX * newVector[0], newSpeedY * newVector[1]];
          return;
        };
        if (groundSpotCheck(obj, tertiaryDirection) == true){
          var newVector = directionToMovement[tertiaryDirection];
          var newSpeedX = oldSpeed + 1.25;
          if (newSpeedX > obj.maxSpeed){
            newSpeedX = obj.maxSpeed;
          }
          var newSpeedY = oldSpeed + 1.25;
          if (newSpeedY > obj.maxSpeed){
            newSpeedY = obj.maxSpeed;
          }
          obj.acceleration = [newSpeedX * newVector[0], newSpeedY * newVector[1]];
          return;
        };
        // If all directions fail, stop
        obj.acceleration = [0,0]
        return;
      };

      //* MOMENTUM COMPONENT ===============

      function inertiaComponent(obj){
        // Always nudge acceleration back towards 0, clamp to 0
        if (obj.acceleration[0] > 0){
          obj.acceleration[0] -= 1;
          if (obj.acceleration[0] < 0){
            obj.acceleration[0] = 0;
          }
        }
        if (obj.acceleration[0] < 0){
          obj.acceleration[0] += 1;
          if (obj.acceleration[0] > 0){
            obj.acceleration[0] = 0;
          }
        }
        if (obj.acceleration[1] > 0){
          obj.acceleration[1] -= 1;
          if (obj.acceleration[1] < 0){
            obj.acceleration[1] = 0;
          }
        }
        if (obj.acceleration[1] < 0){
          obj.acceleration[1] += 1;
          if (obj.acceleration[1] > 0){
            obj.acceleration[1] = 0;
          }
        }
      }

      //* IMPULSE COMPONENT ==========================

      function impulseComponent(obj){
        // Apply movement (impulse) to entity's acceleration, clamp to max speed
        obj.acceleration[0] += 1.25 * obj.movement.x
        obj.acceleration[1] += 1.25 * obj.movement.y;
        if (Math.abs(obj.acceleration[0]) > obj.maxSpeed){
          obj.acceleration[0] = obj.movement.x * obj.maxSpeed;
        }
        if (Math.abs(obj.acceleration[1]) > obj.maxSpeed){
          obj.acceleration[1] = obj.movement.y * obj.maxSpeed;
        }
      }

      //* COMMAND COMPONENTS ===================

      // FSM for X and Y control states, to manage multiple-key inputs
      // A direction command affects entity's state, "facing" direction, and movement (impulse)

      var xNeutralCommandComponent = function(obj, input){
        switch (input){
          case (RUN_RIGHT):
            switch (obj.movement.y){
              case -1:
                obj.facing = "NE";
                break;
              case 0:
                obj.facing = "E";
                break;
              case 1:
                obj.facing = "SE";
                break;
            }
            obj.changeState("running");
            obj.movement.x = 1;
            obj.xCommand = xRightCommandComponent;
            break;
          case (RUN_LEFT):
            switch (obj.movement.y){
              case -1:
                obj.facing = "NW";
                break;
              case 0:
                obj.facing = "W";
                break;
              case 1:
                obj.facing = "SW";
                break;
            }
            obj.changeState("running")
            obj.movement.x = -1;
            obj.xCommand = xLeftCommandComponent;
          break;
        }
      };

      var xLeftCommandComponent = function(obj, input){
        switch (input){
          case (STOP_LEFT):
            obj.movement.x = 0;
            switch (obj.movement.y){
              case -1:
                obj.facing = "N";
              break;
              case 0:
                obj.changeState("standing");
              break;
              case 1:
                obj.facing = "S";
              break;
            }
            obj.xCommand = xNeutralCommandComponent;
            break;
          case (RUN_RIGHT):
            switch (obj.movement.y){
              case -1:
                obj.facing = "NE";
                break;
              case 0:
                obj.facing = "E";
                break;
              case 1:
                obj.facing = "SE";
                break;
            }
            obj.movement.x = 1;
            obj.xCommand = xLeftRightCommandComponent;
            break;
        }
      };

      var xRightCommandComponent = function(obj, input){
        switch (input){
          case (STOP_RIGHT):
            obj.movement.x = 0;
            if (obj.movement.y == 0){
              obj.changeState("standing");
            }
            switch (obj.movement.y){
              case -1:
                obj.facing = "N";
              break;
              case 0:
                obj.changeState("standing");
              break;
              case 1:
                obj.facing = "S";
              break;
            }
            obj.xCommand = xNeutralCommandComponent;
            break;
          case (RUN_LEFT):
            switch (obj.movement.y){
              case -1:
                obj.facing = "NW";
                break;
              case 0:
                obj.facing = "W";
                break;
              case 1:
                obj.facing = "SW";
                break;
            }
            obj.movement.x = -1;
            obj.xCommand = xLeftRightCommandComponent;
            break;
        }
      };

      var xLeftRightCommandComponent = function(obj, input){
        switch (input){
          case (STOP_LEFT):
            switch (obj.movement.y){
              case -1:
                obj.facing = "NE";
                break;
              case 0:
                obj.facing = "E";
                break;
              case 1:
                obj.facing = "SE";
                break;
            }
            obj.movement.x = 1;
            obj.xCommand = xRightCommandComponent;
            break;
          case (STOP_RIGHT):
            switch (obj.movement.y){
              case -1:
                obj.facing = "NW";
                break;
              case 0:
                obj.facing = "W";
                break;
              case 1:
                obj.facing = "SW";
                break;
            }
            obj.movement.x = -1;
            obj.xCommand = xLeftCommandComponent;
            break;
        }
      };

      var yNeutralCommandComponent = function(obj, input){
        switch (input){
          case (RUN_UP):
            switch (obj.movement.x){
              case -1:
                obj.facing = "NW";
                break;
              case 0:
                obj.facing = "N";
                break;
              case 1:
                obj.facing = "NE";
                break;
            }
            obj.changeState("running")
            obj.movement.y = -1;
            obj.yCommand = yUpCommandComponent;
          break;
          case (RUN_DOWN):
            switch (obj.movement.x){
              case -1:
                obj.facing = "SW";
                break;
              case 0:
                obj.facing = "S";
                break;
              case 1:
                obj.facing = "SE";
                break;
            }
            obj.changeState("running")
            obj.movement.y = 1;
            obj.yCommand = yDownCommandComponent;
          break;
        }
      };

      var yUpCommandComponent = function(obj, input){
        switch (input){
          case (STOP_UP):
            obj.movement.y = 0;
            switch (obj.movement.x){
              case -1:
                obj.facing = "W";
              break;
              case 0:
                obj.changeState("standing");
              break;
              case 1:
                obj.facing = "E";
              break;
            }
            obj.yCommand = yNeutralCommandComponent;
            break;
          case (RUN_DOWN):
            switch (obj.movement.x){
              case -1:
                obj.facing = "SW";
                break;
              case 0:
                obj.facing = "S";
                break;
              case 1:
                obj.facing = "SE";
                break;
            }
            obj.movement.y = 1;
            obj.yCommand = yUpDownCommandComponent;
            break;
        }
      };

      var yDownCommandComponent = function(obj, input){
        switch (input){
          case (STOP_DOWN):
            obj.movement.y = 0;
            switch (obj.movement.x){
              case -1:
                obj.facing = "W";
              break;
              case 0:
                obj.changeState("standing");
              break;
              case 1:
                obj.facing = "E";
              break;
            }
            obj.yCommand = yNeutralCommandComponent;
            break;
          case (RUN_UP):
            switch (obj.movement.x){
              case -1:
                obj.facing = "NW";
                break;
              case 0:
                obj.facing = "N";
                break;
              case 1:
                obj.facing = "NE";
                break;
            }
            obj.movement.y = -1;
            obj.yCommand = yUpDownCommandComponent;
            break;
        }
      };

      var yUpDownCommandComponent = function(obj, input){
        switch (input){
          case (STOP_UP):
            obj.movement.y = 1;
            switch (obj.movement.x){
              case -1:
                obj.facing = "W";
                break;
              case 1:
                obj.facing = "E";
                break;
            }
            obj.yCommand = yDownCommandComponent;
            break;
          case (STOP_DOWN):
            obj.movement.y = -1;
            switch (obj.movement.x){
              case -1:
                obj.facing = "W";
                break;
              case 1:
                obj.facing = "E";
                break;
            }
            obj.yCommand = yUpCommandComponent;
            break;
        }
      };


      //* CLASSES ====================================

      //* BASE ENTITY CLASS ====================

      function GameEntity(){
        this.onGround = true;
      };

      GameEntity.prototype.changeState = function(targetState){
        this.state = targetState;
        this.currentAnimationFrameNumber = 0;
      }

      GameEntity.prototype.message = function(recipient, message){
        recipient.receiver(message, this);
      };
      GameEntity.prototype.receiver = function(message){};

      GameEntity.prototype.update = function(){};

      GameEntity.prototype.advanceFrame = function(timestamp){
        if (!this.lastTime){
          this.lastTime = timestamp
        }
        var delta = timestamp - this.lastTime;
        var frameAdvance = Math.floor(delta / FRAMERATE);
        if (frameAdvance >= 1){
          this.currentAnimationFrameNumber = this.currentAnimationFrameNumber + frameAdvance;
          this.lastTime = timestamp;
          if (this.currentAnimationFrameNumber >= this.animation[this.state][this.facing].frames.length) {
            this.currentAnimationFrameNumber = this.animation[this.state][this.facing].frames[0];
          }
        }
        this.currentAnimationFrame.getContext("2d").clearRect(0,0,this.width, this.height);
        this.currentAnimationFrame.getContext("2d").drawImage(
          this.currentSpriteSheet, //source image
          (this.currentAnimationFrameNumber * this.width), //origin x
          0, //origin y
          this.width,
          this.height,
          0,0,
          this.width, this.height
        );
      }

      //* GAME OBJECTS ====================

      //* ACTOR ======================

      function Actor(){ // < GameEntity
        GameEntity.call(this);

        //* STATE ==================
        this.name = "hero";
        this.state = "standing";
        this.solid = true;
        this.width = 400;
        this.height = 400;
        this.depth = 50;
        this.x = 0;
        this.y = 0;
        this.movement = {x: 0, y:0}; // aka impulse
        this.facing = "E";
        this.maxSpeed = 7;
        this.acceleration = [0,0];
        this.hitbox = [25,0,75,75];
        this.feetpoint = { // test pixels for ground checks
          "N": [200, 345],
          "NW": [120, 345],
          "W": [120, 390],
          "SW": [120, 410],
          "S": [200, 410],
          "SE": [280, 410],
          "E": [280,390],
          "NE": [280,345]
        };
        this.animation = {
          "standing": {
            "N": {
              frames: [0],
              filename: "hero_standing_left.png"
            },
            "NW": {
              frames: [0],
              filename: "hero_standing_left.png"
            },
            "W": {
              frames: [0],
              filename: "hero_standing_left.png"
            },
            "SW": {
              frames: [0],
              filename: "hero_standing_left.png"
            },
            "S": {
              frames: [0],
              filename: "hero_standing_right.png"
            },
            "SE": {
              frames: [0],
              filename: "hero_standing_right.png"
            },
            "E": {
              frames: [0],
              filename: "hero_standing_right.png"
            },
            "NE": {
              frames: [0],
              filename: "hero_standing_right.png"
            },
          },
          "running": {
            "N": {
              frames: [0,1,2,3],
              filename: "hero_run_left.png"
            },
            "NW": {
              frames: [0,1,2,3],
              filename: "hero_run_left.png"
            },
            "W": {
              frames: [0,1,2,3],
              filename: "hero_run_left.png"
            },
            "SW": {
              frames: [0,1,2,3],
              filename: "hero_run_left.png"
            },
            "S": {
              frames: [0,1,2,3],
              filename: "hero_run_right.png"
            },
            "SE": {
              frames: [0,1,2,3],
              filename: "hero_run_right.png"
            },
            "E": {
              frames: [0,1,2,3],
              filename: "hero_run_right.png"
            },
            "NE": {
              frames: [0,1,2,3],
              filename: "hero_run_right.png"
            },
          },
          "hurt": {
            "N": {
              frames: [0],
              filename: "hero_hurt_standing_left.png"
            },
            "NW": {
              frames: [0],
              filename: "hero_hurt_standing_left.png"
            },
            "W": {
              frames: [0],
              filename: "hero_hurt_standing_left.png"
            },
            "SW": {
              frames: [0],
              filename: "hero_hurt_standing_left.png"
            },
            "S": {
              frames: [0],
              filename: "hero_hurt_standing_right.png"
            },
            "SE": {
              frames: [0],
              filename: "hero_hurt_standing_right.png"
            },
            "E": {
              frames: [0],
              filename: "hero_hurt_standing_right.png"
            },
            "NE": {
              frames: [0],
              filename: "hero_hurt_standing_right.png"
            },
          }
        };
        this.currentSpriteSheet = new Image(this.width, this.height)
        this.currentSpriteSheet.src = this.animation[this.state][this.facing].filename;
        this.currentAnimationFrameNumber = 0;
        this.currentAnimationFrame = document.createElement("canvas");
        this.currentAnimationFrame.width = this.width;
        this.currentAnimationFrame.height = this.height;
        this.lastTime = undefined;

        //* BEHAVIOR COMPONENTS ============
        this.xCommand = xNeutralCommandComponent;
        this.yCommand = yNeutralCommandComponent;

      };

      //* METHODS =================

      //* INHERIT FROM BASE GAME ENTITY ===========
      Actor.prototype = Object.create(GameEntity.prototype);
      Actor.prototype.constructor = Actor;
      //* NEW ===============
      Actor.prototype.command = function(input){
        this.xCommand(this, input);
        this.yCommand(this, input);

      }
      Actor.prototype.update = function(timestamp){
        // Careful of the order!
        if (this.state == "hurt"){
          this.hurtCounter ++;
        }
        if (this.hurtCounter > 4){
          this.changeState("standing");
          this.hurtCounter = 0;
        }
        impulseComponent(this); // apply impulse
        inertiaComponent(this); // add/subtract inertia
        groundIsWalkableComponent(this); // bump into walls
        detectCollisionComponent(this); // bump into obstacles
        movementComponent(this); // apply movement calc to position
        this.currentSpriteSheet.src = this.animation[this.state][this.facing].filename;
        this.advanceFrame(timestamp); // advance animation frame
      };
      Actor.prototype.receiver = function(message, sender){
        if (message == HIT && sender == fireball){
          this.changeState("hurt");
          this.hurtCounter = 0;
        }
      }

      //* FIREBALLS ========================

      function Fireball(){ // < GameEntity
        GameEntity.call(this);
        this.name = "fireball";
        this.facing = null;
        this.solid = false;
        this.onGround = false;
        this.width = 200;
        this.height = 200;
        this.depth = 100;
        this.x = -200;
        this.y = -200;
        this.zIndex = 400;
        this.acceleration = [9, 0];
        this.originalAcceleration = [9, 0];
        this.hitbox = [50,50,150,150];
        this.currentAnimationFrame = document.createElement("canvas");
        this.currentAnimationFrame.width = this.width;
        this.currentAnimationFrame.height = this.height;
        var ctx = this.currentAnimationFrame.getContext("2d");
        ctx.beginPath();
        ctx.arc(100,100,100,0,2*Math.PI, false);
        ctx.fillStyle = "hsla(1,99%,60%,.5)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(100,100,75,0,2*Math.PI, false);
        ctx.fillStyle = "hsla(1,99%,60%,.5)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(100,100,50,0,2*Math.PI, false);
        ctx.fillStyle = "orange";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(100,100,25,0,2*Math.PI, false);
        ctx.fillStyle = "yellow";
        // ctx.fill();
      }

      Fireball.prototype = Object.create(GameEntity.prototype);
      Fireball.prototype.constructor = Fireball;

      Fireball.prototype.update = function(){
        detectCollisionComponent(this);
        movementComponent(this);
        if (this.y >= (this.zIndex - (this.height)*SCALE)){
          //restart
          this.x = -200;
          this.y = -200;
          this.acceleration = [this.originalAcceleration[0], this.originalAcceleration[1]];
        }
        this.acceleration[1] += .5;
      }

      //* ===============================

      function drawEntity(entity, context){
        context.drawImage(
          entity.currentAnimationFrame, //image
          0, 0, //origin x, y
          entity.width, entity.height, //origin w & h
          entity.x, entity.y, //map position
          (entity.width * SCALE), //drawn width and height
          (entity.height * SCALE)
        );
      };

      //* ===============================

      var hero = new Actor(),
          twin = new Actor(),
          fireball = new Fireball();
          canvas = document.getElementById("display"),
          ctx = canvas.getContext('2d');

      var entities = [hero,twin,fireball];
      var entitiesDepthOrder = [hero,twin,fireball];

      hero.x = 160;
      hero.y = 210;

      twin.name = "twin";
      twin.x = 600;
      twin.y = 200;
      twin.command = function(){};

      //* BEGIN GAME LOOP ====================
      var gameLoop = window.requestAnimationFrame(tick);

      function tick(timestamp){
        for (var i = 0; i < entities.length; i++){
          entities[i].update(timestamp);
        };
        entitiesDepthOrder.sort(function(a, b){ //sort by y position
          return ((a.zIndex) - (b.zIndex));
        });
        ctx.clearRect(0, 0, 1200, 800);
        for (var i = 0; i < entitiesDepthOrder.length; i++){
          drawEntity(entitiesDepthOrder[i], ctx);
        }
        window.requestAnimationFrame(tick);
      };

      //* KEY LISTENERS ========================

      window.addEventListener("keydown", function(e){
        switch (e.keyCode){
          case 37:
              e.preventDefault();
              hero.command(RUN_LEFT);
              break;
          case 38:
              e.preventDefault();
              hero.command(RUN_UP);
              break;
          case 39:
              e.preventDefault();
              hero.command(RUN_RIGHT);
              break;
          case 40:
              e.preventDefault();
              hero.command(RUN_DOWN);
              break;
        }
      });

      window.addEventListener("keyup", function(e){
        switch (e.keyCode){
          case 37:
            hero.command(STOP_LEFT);
            break;
          case 38:
            hero.command(STOP_UP);
            break;
          case 39:
            hero.command(STOP_RIGHT);
            break;
          case 40:
            hero.command(STOP_DOWN);
            break;
        }
      });


};

// main();
      </script>



  </body>

</html>